<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>CAVE simulator (WebXR)</title>
  <link rel="stylesheet" crossorigin href="/assets/index-Dd6lRqA4.css">
</head>
<body>
<div id="info">
  CAVE Simulator (WebXR). Head and teapot are draggable.<br/>
  "L" Left Eye | "R" Right Eye | "S" toggle scene | Arrows to move walls | "M" reset<br/>
</div>

<script src="https://unpkg.com/three@0.139.2/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.139.2/examples/js/controls/OrbitControls.js"></script>
<script src="https://unpkg.com/three@0.139.2/examples/js/controls/DragControls.js"></script>
<script src="https://unpkg.com/three@0.139.2/examples/js/geometries/TeapotGeometry.js"></script>
<script src="https://unpkg.com/three@0.139.2/examples/js/loaders/GLTFLoader.js"></script>

<script>
// ============================================================
// === DisplaySurface class
// ============================================================
class DisplaySurface {
  constructor(name, origin, u_vector, v_vector) {
    this.name = name;
    this.origin = origin;
    this.u = u_vector;
    this.v = v_vector;
    this.b = true;
  }
  viewMatrix(eye) {
    const uHat = this.u.clone().normalize();
    const vHat = this.v.clone().normalize();
    const nHat = new THREE.Vector3().crossVectors(uHat, vHat).normalize();
    const upVector = vHat.clone();
    const target = eye.clone().sub(nHat);
    const mat = new THREE.Matrix4();
    mat.lookAt(eye, target, upVector);
    const translate = new THREE.Matrix4().makeTranslation(-eye.x, -eye.y, -eye.z);
    mat.multiply(translate);
    return mat;
  }
  projectionMatrix(eye, znear, zfar) {
    const uHat = this.u.clone().normalize();
    const vHat = this.v.clone().normalize();
    const nHat = new THREE.Vector3().crossVectors(uHat, vHat).normalize();
    const va = this.origin.clone().sub(eye);
    const vb = this.origin.clone().add(this.u).sub(eye);
    const vc = this.origin.clone().add(this.v).sub(eye);
    const d = -va.dot(nHat);
    const left = (uHat.dot(va) * znear) / d;
    const right = (uHat.dot(vb) * znear) / d;
    const bottom = (vHat.dot(va) * znear) / d;
    const top = (vHat.dot(vc) * znear) / d;
    const proj = new THREE.Matrix4();
    proj.makePerspective(left, right, top, bottom, znear, zfar);
    return proj;
  }
}

// ============================================================
// === Globals
// ============================================================
let renderer, scene, camera;
let displaySurfaces, displaySurfaceScene, displaySurfaceTargets;
let eyeCenter, eyeScene;
let orbitControl, mixer;
let showScene = true;
let wallAngle = Math.PI / 2;
const angleStep = THREE.MathUtils.degToRad(2);
let xrSession = null;
let vrRig;

// ============================================================
// === Helper rotation functions
// ============================================================
function rotatePointAroundAxis(P, B, axis, angle) {
  const v = P.clone().sub(B);
  v.applyAxisAngle(axis, angle);
  return B.clone().add(v);
}
function rotateVectorAroundAxis(u, axis, angle) {
  const v = u.clone();
  v.applyAxisAngle(axis, angle);
  return v;
}

// ============================================================
// === Wall updates
// ============================================================
function updateWallAngle() {
  const leftWall = displaySurfaces.find(d => d.name === "Left");
  const rightWall = displaySurfaces.find(d => d.name === "Right");
  const vBase = new THREE.Vector3(0, 300, 0);
  const axisY = new THREE.Vector3(0,1,0);

  const B_left = new THREE.Vector3(-150, -150, -150);
  const A_base_left = new THREE.Vector3(-150, -150, +150);
  const u_base_left = new THREE.Vector3(0,0,-300);

  const A_new_left = rotatePointAroundAxis(A_base_left, B_left, axisY, wallAngle - Math.PI/2);
  const u_new_left = rotateVectorAroundAxis(u_base_left, axisY, wallAngle - Math.PI/2);

  leftWall.origin.copy(A_new_left);
  leftWall.u.copy(u_new_left);
  leftWall.v.copy(vBase);

  const rightOrigin = new THREE.Vector3(150, -150, -150);
  const rightU = new THREE.Vector3(0, 0, 300);
  rightU.applyAxisAngle(axisY, Math.PI / 2 - wallAngle);
  rightWall.origin.copy(rightOrigin);
  rightWall.u.copy(rightU);
  rightWall.v.copy(vBase);
}

// ============================================================
// === Eye + Head scene
// ============================================================
function createEyeScene() {
  const IPD = 6.8;
  eyeCenter = new THREE.Vector3(50, 20, 50);
  const eyeL = new THREE.Vector3(-IPD/2, 10, -6);
  const eyeR = new THREE.Vector3(IPD/2, 10, -6);

  eyeScene = new THREE.Scene();

  const headGeom = new THREE.SphereGeometry(10, 32, 22);
  const headMat = new THREE.MeshPhongMaterial({ color: 0xaaaaaa });
  const head = new THREE.Mesh(headGeom, headMat);
  head.name = "Head";
  head.position.copy(eyeCenter);
  eyeScene.add(head);

  const eyeGeom = new THREE.SphereGeometry(3, 32, 22);
  const eyeLMesh = new THREE.Mesh(eyeGeom, new THREE.MeshPhongMaterial({ color: 0xff0000 }));
  eyeLMesh.name = "EyeL";
  eyeLMesh.position.copy(eyeL);
  head.add(eyeLMesh);

  const eyeRMesh = new THREE.Mesh(eyeGeom, new THREE.MeshPhongMaterial({ color: 0x0000ff }));
  eyeRMesh.name = "EyeR";
  eyeRMesh.position.copy(eyeR);
  head.add(eyeRMesh);

  createLights(eyeScene);
}

// ============================================================
// === WebXR setup
// ============================================================
function createRenderer() {
  renderer = new THREE.WebGLRenderer({ preserveDrawingBuffer: true, antialias: true });
  renderer.autoClear = false;
  renderer.xr.enabled = true;
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  setupWebXRButton();
}

function setupWebXRButton() {
  const button = document.createElement('button');
  button.style.position = 'absolute';
  button.style.right = '10px';
  button.style.bottom = '10px';
  button.style.padding = '8px 12px';
  button.style.background = '#444';
  button.style.color = '#fff';
  button.style.border = 'none';
  button.style.borderRadius = '4px';
  button.style.cursor = 'pointer';
  button.style.zIndex = '999';
  button.textContent = 'Enter VR';

  if (navigator.xr) {
    navigator.xr.isSessionSupported('immersive-vr').then(supported => {
      if (!supported) button.style.display = 'none';
    });
  } else {
    button.style.display = 'none';
  }

  button.addEventListener('click', async () => {
    if (!xrSession) {
      try {
        const session = await navigator.xr.requestSession('immersive-vr', {
          optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking', 'local']
        });
        await onSessionStarted(session);
        button.textContent = 'Exit VR';
      } catch (err) {
        console.warn('XR session failed', err);
      }
    } else {
      xrSession.end();
      button.textContent = 'Enter VR';
    }
  });

  document.body.appendChild(button);
}

async function onSessionStarted(session) {
  xrSession = session;
  renderer.xr.setSession(session);
  session.addEventListener('end', () => { xrSession = null; });
  await session.requestReferenceSpace('local');
}

// ============================================================
// === Scene creation
// ============================================================
function createLights(scn) {
  const ambient = new THREE.AmbientLight(0x888888, 0.4);
  const point = new THREE.PointLight(0xffffff, 0.8);
  point.position.z += 200;
  scn.add(ambient, point);
}

function createScene() {
  scene = new THREE.Scene();
  const geometry = new THREE.TeapotGeometry(40, 15);
  const material = new THREE.MeshPhongMaterial({ color: 0xffffff });
  const teapot = new THREE.Mesh(geometry, material);
  teapot.name = "Teapot";
  teapot.position.z -= 70;
  scene.add(teapot);

  const loader = new THREE.GLTFLoader();
  loader.load("anime_girl_model.glb", gltf => {
    const model = gltf.scene;
    model.position.set(0, -20, -70);
    model.scale.set(30, 30, 30);
    scene.add(model);
    if (gltf.animations?.length) {
      mixer = new THREE.AnimationMixer(model);
      gltf.animations.forEach(clip => mixer.clipAction(clip).play());
    }
  });
  createLights(scene);
}

// ============================================================
// === Display surfaces and textures
// ============================================================
function createDisplaySurfaces() {
  displaySurfaces = [];
  displaySurfaces.push(new DisplaySurface("Front", new THREE.Vector3(-150, -150, -150), new THREE.Vector3(300,0,0), new THREE.Vector3(0,300,0)));
  displaySurfaces.push(new DisplaySurface("Left", new THREE.Vector3(-150, -150, 150), new THREE.Vector3(0,0,-300), new THREE.Vector3(0,300,0)));
  displaySurfaces.push(new DisplaySurface("Right", new THREE.Vector3(150, -150, -150), new THREE.Vector3(0,0,300), new THREE.Vector3(0,300,0)));
  displaySurfaces.push(new DisplaySurface("Floor", new THREE.Vector3(-150,-150,150), new THREE.Vector3(300,0,0), new THREE.Vector3(0,0,-300)));
}

function createDisplaySurfaceTargets() {
  const SIZE = 1024;
  displaySurfaceTargets = displaySurfaces.map(() => new THREE.WebGLRenderTarget(SIZE, SIZE));
}

function createDisplaySurfaceScene() {
  displaySurfaceScene = new THREE.Scene();
  displaySurfaces.forEach((surf, i) => {
    const origin = surf.origin;
    const u = surf.u;
    const v = surf.v;
    const geom = new THREE.BufferGeometry();
    const p0 = origin.clone();
    const p1 = origin.clone().add(u);
    const p2 = origin.clone().add(u).add(v);
    const p3 = origin.clone().add(v);
    const vertices = new Float32Array([
      p0.x,p0.y,p0.z, p1.x,p1.y,p1.z, p2.x,p2.y,p2.z, p3.x,p3.y,p3.z
    ]);
    const indices = [0,1,3,1,2,3];
    const uvs = new Float32Array([0,0,1,0,1,1,0,1]);
    geom.setAttribute('position', new THREE.BufferAttribute(vertices,3));
    geom.setAttribute('uv', new THREE.BufferAttribute(uvs,2));
    geom.setIndex(indices);
    geom.computeVertexNormals();
    const mat = new THREE.MeshPhongMaterial({ map: displaySurfaceTargets[i].texture, side: THREE.DoubleSide });
    const mesh = new THREE.Mesh(geom, mat);
    mesh.name = surf.name;
    displaySurfaceScene.add(mesh);
  });
  createLights(displaySurfaceScene);
}

// ============================================================
// === Camera, Controls, Helpers
// ============================================================
function createCamera() {
  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 10000);
  camera.position.set(100, 100, 300);
  camera.lookAt(0,0,0);
}

function enableOrbitCamera(cam) {
  orbitControl = new THREE.OrbitControls(cam, renderer.domElement);
  orbitControl.minDistance = 120;
  orbitControl.maxDistance = 50000;
}

function addDragControlToObjects() {
  const objects = [scene.getObjectByName("Teapot"), eyeScene.getObjectByName("Head")];
  const controls = new THREE.DragControls(objects, camera, renderer.domElement);
  controls.addEventListener('hoveron', () => orbitControl.enabled = false);
  controls.addEventListener('hoveroff', () => orbitControl.enabled = true);
}

// ============================================================
// === Animation loop
// ============================================================
const clock = new THREE.Clock();

function animate() {
  const delta = clock.getDelta();
  if (mixer) mixer.update(delta);
  renderer.setClearColor(0x808080);
  renderer.clear();

  const gl = renderer.getContext();
  if (showScene) renderer.render(scene, camera);

  for (let [i, surf] of displaySurfaces.entries()) {
    renderer.setRenderTarget(displaySurfaceTargets[i]);
    renderer.setClearColor(0x404040);
    renderer.clear();

    gl.colorMask(1, 0, 0, 0);
    let eyeL = eyeScene.getObjectByName("EyeL").getWorldPosition(new THREE.Vector3());
    let viewL = surf.viewMatrix(eyeL);
    let projL = surf.projectionMatrix(eyeL, 1, 1000);
    let camL = cameraFromViewProj(viewL, projL);
    renderer.render(scene, camL);

    gl.colorMask(0, 1, 1, 0);
    let eyeR = eyeScene.getObjectByName("EyeR").getWorldPosition(new THREE.Vector3());
    let viewR = surf.viewMatrix(eyeR);
    let projR = surf.projectionMatrix(eyeR, 1, 1000);
    let camR = cameraFromViewProj(viewR, projR);
    renderer.clearDepth();
    renderer.render(scene, camR);
    gl.colorMask(1, 1, 1, 0);
  }

  renderer.setRenderTarget(null);
  renderer.setClearColor(0x000000);
  renderer.render(displaySurfaceScene, camera);
  renderer.render(eyeScene, camera);
}

// ============================================================
// === Init
// ============================================================
createRenderer();
createDisplaySurfaces();
createDisplaySurfaceTargets();
createDisplaySurfaceScene();
updateWallAngle();
createEyeScene();
createScene();
createCamera();

vrRig = new THREE.Group();
vrRig.name = "VRRig";
vrRig.add(camera);
scene.add(vrRig);

enableOrbitCamera(camera);
addDragControlToObjects();
renderer.setAnimationLoop(animate);

// ============================================================
// === Keyboard events
// ============================================================
window.addEventListener('keydown', e => {
  switch(e.code) {
    case 'KeyL': camera.position.copy(eyeScene.getObjectByName("EyeL").getWorldPosition(new THREE.Vector3())); break;
    case 'KeyR': camera.position.copy(eyeScene.getObjectByName("EyeR").getWorldPosition(new THREE.Vector3())); break;
    case 'KeyS': showScene = !showScene; break;
    case 'ArrowLeft': wallAngle -= angleStep; updateWallAngle(); break;
    case 'ArrowRight': wallAngle += angleStep; updateWallAngle(); break;
    case 'KeyM': wallAngle = Math.PI/2; updateWallAngle(); break;
  }
});

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ============================================================
function cameraFromViewProj(view, proj) {
  const cam = camera.clone();
  const inv = new THREE.Matrix4().copy(view).invert();
  cam.position.set(inv.elements[12], inv.elements[13], inv.elements[14]);
  cam.setRotationFromMatrix(view);
  cam.projectionMatrix = proj.clone();
  return cam;
}
</script>
</body>
</html>
