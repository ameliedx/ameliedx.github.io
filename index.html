<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>CAVE simulator (with WebXR)</title>
  <link rel="stylesheet" crossorigin href="/assets/index-Dd6lRqA4.css">
</head>
<body>
<div id="info">
	CAVE Simulator. The head and teapot are draggable. <br />
	"L" See from Left Eye | "R" See from Right Eye | "S" toggle show scene  <br />
</div>

<script src="https://unpkg.com/three@0.139.2/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.139.2/examples/js/controls/OrbitControls.js"></script>
<script src="https://unpkg.com/three@0.139.2/examples/js/controls/DragControls.js"></script>
<script src="https://unpkg.com/three@0.139.2/examples/js/geometries/TeapotGeometry.js"></script>
<script src="https://unpkg.com/three@0.139.2/examples/js/loaders/GLTFLoader.js"></script>

<script>
/* ====================
   DisplaySurface class (view + projection)
   ==================== */
class DisplaySurface {
    constructor(name, origin, u_vector, v_vector) {
        this.name = name;
        this.origin = origin;
        this.u = u_vector;
        this.v = v_vector;
        this.b = true;
    }

    viewMatrix(eye) {
        const uHat = this.u.clone().normalize();
        const vHat = this.v.clone().normalize();
        const nHat = new THREE.Vector3().crossVectors(uHat, vHat).normalize();

        // Up = direction of v on the surface
        const upVector = vHat.clone();

        // Target is eye - n (look toward surface)
        const target = eye.clone().sub(nHat);

        var mat = new THREE.Matrix4();
        mat.lookAt(eye, target, upVector);

        const translate = new THREE.Matrix4().makeTranslation(-eye.x, -eye.y, -eye.z);
        mat.multiply(translate);

        return mat;
    }

    projectionMatrix(eye, znear, zfar) {
        const uHat = this.u.clone().normalize();
        const vHat = this.v.clone().normalize();
        const nHat = new THREE.Vector3().crossVectors(uHat, vHat).normalize();

        const va = this.origin.clone().sub(eye);                    // bottom-left
        const vb = this.origin.clone().add(this.u).sub(eye);        // bottom-right
        const vc = this.origin.clone().add(this.v).sub(eye);        // top-left

        const d = -va.dot(nHat); // positive distance from eye to plane along n

        const left   = (uHat.dot(va) * znear) / d;
        const right  = (uHat.dot(vb) * znear) / d;
        const bottom = (vHat.dot(va) * znear) / d;
        const top    = (vHat.dot(vc) * znear) / d;

        const proj = new THREE.Matrix4();
        proj.makePerspective(left, right, top, bottom, znear, zfar);
        return proj;
    }
}

/* ====================
   Globals
   ==================== */
var renderer, scene, camera;
var displaySurfaces, displaySurfaceScene, displaySurfaceTargets;
var eyeCenter, eyeScene;
var orbitControl;
var showScene = true;
var xrSession = null;

/* ====================
   Drag controls
   ==================== */
function addDragControlToObjects() {
    var objects = [];
    objects.push(scene.getObjectByName("Teapot"));
    objects.push(eyeScene.getObjectByName("Head"));

    var controls = new THREE.DragControls(objects, camera, renderer.domElement);
    controls.addEventListener('hoveron', function (event) { orbitControl.enabled = false; } );
    controls.addEventListener('hoveroff', function (event) { orbitControl.enabled = true; } );
    controls.addEventListener('dragstart', function (event) { event.object.material.emissive.set(0xaaaaaa); } );
    controls.addEventListener('dragend', function (event) { event.object.material.emissive.set(0x000000); } );
}

/* ====================
   Eye scene (head + two eyes)
   ==================== */
function createEyeScene() {
    var IPD = 6.8;
    eyeCenter = new THREE.Vector3(50, 20, 50);
    var eyeL = new THREE.Vector3(- IPD/2, 10, -6);
    var eyeR = new THREE.Vector3(+ IPD/2, 10, -6);

    eyeScene = new THREE.Scene();

    var geometry = new THREE.SphereGeometry(10, 32, 22);
    var material = new THREE.MeshPhongMaterial({ color: 0xaaaaaa });
    var head = new THREE.Mesh(geometry, material);
    head.name = "Head";
    head.position.set(eyeCenter.x, eyeCenter.y, eyeCenter.z);
    eyeScene.add(head);

    var geometryEye = new THREE.SphereGeometry(3, 32, 22);
    var materialL = new THREE.MeshPhongMaterial({ color: 0xff0000 });
    var eyeMeshL = new THREE.Mesh(geometryEye, materialL);
    eyeMeshL.name = "EyeL";
    eyeMeshL.position.set(eyeL.x, eyeL.y, eyeL.z);
    head.add(eyeMeshL);

    var materialR = new THREE.MeshPhongMaterial({ color: 0x0000ff });
    var eyeMeshR = new THREE.Mesh(geometryEye, materialR);
    eyeMeshR.name = "EyeR";
    eyeMeshR.position.set(eyeR.x, eyeR.y, eyeR.z);
    head.add(eyeMeshR);

    createLights(eyeScene);
}

/* ====================
   Renderer + WebXR setup
   ==================== */
function createRenderer() {
    renderer = new THREE.WebGLRenderer({ preserveDrawingBuffer: true, antialias: true });
    renderer.autoClear = false;
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true; // enable XR support in renderer
    document.body.appendChild(renderer.domElement);
}

/* Create a simple Enter VR button (lightweight, no external module) */
function setupWebXRButton() {
    const button = document.createElement('button');
    button.style.position = 'absolute';
    button.style.right = '10px';
    button.style.bottom = '10px';
    button.style.padding = '8px 12px';
    button.style.zIndex = '999';
    button.style.background = '#444';
    button.style.color = '#fff';
    button.style.border = 'none';
    button.style.borderRadius = '4px';
    button.style.cursor = 'pointer';
    button.textContent = 'Enter VR';

    // update supported state
    if (navigator.xr) {
        navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
            if (!supported) {
                button.style.display = 'none';
            }
        }).catch(()=>{ button.style.display = 'none'; });
    } else {
        button.style.display = 'none';
    }

    button.addEventListener('click', async () => {
        if (!xrSession) {
            try {
                const session = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking', 'local'] });
                await onSessionStarted(session);
                button.textContent = 'Exit VR';
            } catch (err) {
                console.warn('Failed to start XR session:', err);
            }
        } else {
            await xrSession.end();
        }
    });

    document.body.appendChild(button);
}

async function onSessionStarted(session) {
    xrSession = session;
    renderer.xr.setSession(session);

    // when XR session ends -> cleanup
    session.addEventListener('end', () => {
        xrSession = null;
        // restore any states if needed
    });

    // request reference space (three.js handles internally but we keep this to be explicit)
    try {
        await session.requestReferenceSpace('local');
    } catch (e) {
        // ignore if not supported
    }
}

/* ====================
   Camera / lights / scene
   ==================== */
function enableOrbitCamera(cam, renderer) {
    orbitControl = new THREE.OrbitControls(cam, renderer.domElement );
    orbitControl.minDistance = 120;
    orbitControl.maxDistance = 50000;
}

function createLights(scn) {
    var ambientLight = new THREE.AmbientLight(0x888888, 0.4);
    scn.add(ambientLight);
    var pointLight = new THREE.PointLight(0xffffff, 0.8);
    pointLight.position.z += 200;
    scn.add(pointLight);
}

function createScene() {
    scene = new THREE.Scene();

    var geometry = new THREE.TeapotGeometry(40, 15);
    var material = new THREE.MeshPhongMaterial({ color: 0xffffff });
    var teapot = new THREE.Mesh(geometry, material);
    teapot.name = "Teapot";
    teapot.position.z -= 70;
    scene.add(teapot);

    var loader = new THREE.GLTFLoader();
    loader.load("anime_girl_model.glb",
        function (gltf) {
            const model = gltf.scene;
            model.name = "Anime_girl";
            model.position.set(0, -20, -70);
            model.scale.set(30, 30, 30);
            scene.add(model);

            if (gltf.animations && gltf.animations.length > 0) {
                mixer = new THREE.AnimationMixer(model);
                gltf.animations.forEach((clip) => {
                    mixer.clipAction(clip).play();
                });
            }
        },
        function (xhr) { /* progress */ },
        function (error) { console.error('GLTF load error', error); }
    );

    createLights(scene);
}

function createDisplaySurfaceScene() {
    displaySurfaceScene = new THREE.Scene();

    for (var [index, displaySurface] of displaySurfaces.entries()) {
        var origin = displaySurface.origin;
        var u = displaySurface.u;
        var v = displaySurface.v;

        var geometry = new THREE.BoxGeometry(u.length(), v.length(), 0.01);
        var material = new THREE.MeshPhongMaterial({ map: displaySurfaceTargets[index].texture });
        var cube = new THREE.Mesh(geometry, material);
        cube.name = displaySurface.name;
        if (displaySurface.name == "Left") cube.rotation.y = Math.PI / 2;
        if (displaySurface.name == "Right") cube.rotation.y = - Math.PI / 2;
        if (displaySurface.name == "Floor") {
            cube.rotation.x = Math.PI / 2;
            cube.rotation.z = Math.PI;
        }

        var uHalf = u.clone().multiplyScalar(0.5);
        var vHalf = v.clone().multiplyScalar(0.5);
        var center = new THREE.Vector3().addVectors(origin, uHalf);
        center.add(vHalf);
        cube.position.set(center.x, center.y, center.z);

        displaySurfaceScene.add(cube);
    }

    createLights(displaySurfaceScene);
}

function createDisplaySurfaceTargets() {
    const SIZE = 1024;
    displaySurfaceTargets = [];
    for (var v of displaySurfaces)
        displaySurfaceTargets.push(new THREE.WebGLRenderTarget(SIZE, SIZE));
}

function createCamera() {
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    camera.position.set(100, 100, 300);
    camera.lookAt(0, 0, 0);
}

function createDisplaySurfaces() {
    displaySurfaces = [];
    var frontScreen = new DisplaySurface("Front",
        new THREE.Vector3(-150.0, -150.0, -150.0),
        new THREE.Vector3(300.0, 0.0, 0.0),
        new THREE.Vector3(0.0, 300.0, 0.0));
    displaySurfaces.push(frontScreen);

    var leftScreen = new DisplaySurface("Left",
        new THREE.Vector3(-150.0, -150.0, 150.0),
        new THREE.Vector3(0.0, 0.0, -300.0),
        new THREE.Vector3(0.0, 300.0, 0.0));
    displaySurfaces.push(leftScreen);

    var rightScreen = new DisplaySurface("Right",
        new THREE.Vector3(150.0, -150.0, -150.0),
        new THREE.Vector3(0.0, 0.0, 300.0),
        new THREE.Vector3(0.0, 300.0, 0.0));
    displaySurfaces.push(rightScreen);

    var floorScreen = new DisplaySurface("Floor",
        new THREE.Vector3(-150.0, -150.0, 150.0),
        new THREE.Vector3(300.0, 0.0, 0.0),
        new THREE.Vector3(0.0, 0.0, -300.0));
    displaySurfaces.push(floorScreen);
}

function getLeftEyePosition() {
    var eye = eyeScene.getObjectByName("EyeL");
    return eye.getWorldPosition(new THREE.Vector3());
}

function getRightEyePosition() {
    var eye = eyeScene.getObjectByName("EyeR");
    return eye.getWorldPosition(new THREE.Vector3());
}

function cameraFromViewProj(view, proj) {
    var cam = camera.clone();
    var inv = new THREE.Matrix4();
    inv.copy(view).invert();
    // set position from inverse matrix (elements 12,13,14)
    cam.position.set(inv.elements[12], inv.elements[13], inv.elements[14]);
    cam.setRotationFromMatrix(view);
    cam.projectionMatrix = proj.clone();
    return cam;
}

const clock = new THREE.Clock();
var mixer = null;

/* ====================
   Animation loop (renderer.setAnimationLoop used for XR compatibility)
   ==================== */

// === VR Camera Rig ===
// This group represents the user's body in VR; it contains the camera and follows the headset.


var animate = function (timestamp) {
    var gl = renderer.getContext();

    const delta = clock.getDelta();
    if (mixer) mixer.update(delta);

    // If in XR and presenting, sync head position with XR camera
    if (renderer.xr && renderer.xr.isPresenting) {
        // Get the Three.js XR camera (a Camera or ArrayCamera)
        try {
            const xrCamera = renderer.xr.getCamera();
            const head = eyeScene.getObjectByName("Head");

            if (xrCamera) {
                // Extract position and rotation from the XR camera
                const pos = new THREE.Vector3();
                const rot = new THREE.Quaternion();
                const scale = new THREE.Vector3();
                xrCamera.matrixWorld.decompose(pos, rot, scale);

                // Update VR rig position and rotation
                vrRig.position.copy(pos);
                vrRig.quaternion.copy(rot);
            }

            // Update the virtual head to follow the VR rig
            if (head) {
                head.position.copy(vrRig.position);
                head.quaternion.copy(vrRig.quaternion);
            }
        } catch (e) {
            // Ignore if not available
        }
    }

    // 1. Render main scene objects (third-person view)
    renderer.setClearColor(0x808080);
    renderer.clear();
    if (showScene) renderer.render(scene, camera);

    // 2. Render scene onto each display target (stereo)
    for (let [index, displaySurface] of displaySurfaces.entries()) {
        renderer.setRenderTarget(displaySurfaceTargets[index]);
        renderer.setClearColor(0x404040);
        renderer.clear();

        // Left eye -> RED channel
        gl.colorMask(1, 0, 0, 0);
        var eyeL = getLeftEyePosition();
        var viewL = displaySurface.viewMatrix(eyeL);
        var projL = displaySurface.projectionMatrix(eyeL, 1, 10000);
        var leftCamera = cameraFromViewProj(viewL, projL);
        renderer.render(scene, leftCamera);

        // Right eye -> GREEN + BLUE channels
        gl.colorMask(0, 1, 1, 0);
        var eyeR = getRightEyePosition();
        var viewR = displaySurface.viewMatrix(eyeR);
        var projR = displaySurface.projectionMatrix(eyeR, 1, 10000);
        var rightCamera = cameraFromViewProj(viewR, projR);
        renderer.clearDepth();
        renderer.render(scene, rightCamera);

        gl.colorMask(1, 1, 1, 0);
    }

    renderer.setRenderTarget(null);
    renderer.setClearColor(0x000000);

    // 3. Render textured display surfaces (the CAVE walls)
    renderer.render(displaySurfaceScene, camera);

    // 4. Render eyes/head
    renderer.render(eyeScene, camera);

    // When using setAnimationLoop, do not call requestAnimationFrame here.
};


/* ====================
   Keyboard events
   ==================== */
window.addEventListener('keydown', function (event) {
    switch (event.code) {
        case 'KeyL':
            var eye = getLeftEyePosition();
            camera.position.set(eye.x, eye.y, eye.z);
            break;
        case 'KeyR':
            var eye = getRightEyePosition();
            camera.position.set(eye.x, eye.y, eye.z);
            break;
        case 'KeyS':
            showScene = !showScene;
            break;
        case 'KeyT':
            var viewF = displaySurfaces[0].viewMatrix(new THREE.Vector3(50,20,100));
            var viewL = displaySurfaces[1].viewMatrix(new THREE.Vector3(50,20,100));
            console.log("View matrices:");
            console.log(viewF);
            console.log(viewL);
            break;
    }
});

/* ====================
   Init everything
   ==================== */
createRenderer();
createDisplaySurfaces();
createDisplaySurfaceTargets();
createDisplaySurfaceScene();
createEyeScene();
createScene();

var vrRig = new THREE.Group();
vrRig.name = "VRRig";
vrRig.add(camera);
scene.add(vrRig);

createCamera();
enableOrbitCamera(camera, renderer);
addDragControlToObjects();
setupWebXRButton();

// Use renderer.setAnimationLoop for both XR and non-XR rendering
renderer.setAnimationLoop(animate);

/* ====================
   Resize handling
   ==================== */
window.addEventListener('resize', function () {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
